\chapter{Implementation}
This chapter includes the implementation of controllers and components. The chapter will be seperated into two section, a section for the inverted pendulum and another section for the rocket. An Arduino will be used as the platform to implement the hardware and software on.    


\subsection{MCU}\label{sec:MCU}
TBD

\todo{Sampling speed for both system, and argument that the arduino is fine with its 16 MHz clock speed.}

\section{Inverted Pendulum Implementation}
This section describes the implementation of the controller design cf. section \ref{sec:IPController}

\subsection{Implementing Sensors}
\todo{Consider the sampling speed of the sensors, when having the complete closed loop transfer function. - Mathias}


\subsubsection*{Potentiometer}\label{section:PotmeterImplementation}
The system consist of multiple sensors, as decribed cf. section \ref{sec:IPDesc}, where two of those is potentiometers. The potentiometers are linear Bourns 100 k$\Omega$. The potentiometers is tested cf. appendix \ref{appendix:PotMeterTest}. The appendix concluded with a first order approximation of both potentiometers. The approximation for Pot$_{arm}$ is:

\begin{equation}
\theta_a\ =\ 63,64 \cdot V_{{Pot}_{arm}} - 117,77
\end{equation}
\startexplain
	\explain{$\text{V}_{{Pot}_{arm}}$ is the output voltage of the  arms potentiometer}{V}
	\explain{$\theta_a$ is the angle of the arm}{$^\circ$}
\stopexplain

The approximation for Pot$_{stick}$ is:

\begin{equation}
\theta_s\ =\ 66,66 \cdot \text{VPot}_{stick} - 170,46
\end{equation}

\startexplain
	\explain{$\text{V}_{{Pot}_{stick}}$ is the output voltage of the stick potentiometer.}{V}
	\explain{$\theta_s$ is the angle of the stick, but where zero degrees is when the stick has a zero degree deviation from the arm}{$^\circ$}
\stopexplain

An example of implementing this is done trough a pseudo-code which converts the not limits to degree. Mapping can be used because of the linearity of the potentiometer.
\begin{lstlisting}
void loop() {
  // read the input on A0 and A1:
  int PotArm = analogRead(A0);
  int PotStick = analogRead(A1);

  double VPotarm = PotArm / 204.8;
  double ThetaA = 66.66 * VPotarm - 170.46;
  
  double VPotstick = PotStick / 204.8;
  double ThetaS = 63.64 * VPotstick - 117.77;
}
\end{lstlisting}    

The sampling time of the sensors can be an important aspect when ensuring stability of the control system. The sensor sampling can not be to slow. Considering that the sensor is a potentiometer which does not have any active components then the only limit is the Arduino. Arduino specifies that calling a analogRead takes approximately 100 $\upmu$s which corresponds to a sampling frequency of 10 kHz. This is considered fast enough for the system and is not considered a problem. 

\subsubsection*{Tachometer}
The tachometer and its precision has been tested in appendix \ref{appendix:RPMTest}. The test concluded that the internal tachometers precision is within the limit of what could implemented. The tachometer outputs a voltage which is close to linear with the number of revolutions per minute.

The test concluded with the first order function:
\begin{equation}
H_{tm}\ =\ \dfrac{\dfrac{1000\ \text{RPM}}{3\ \text{V}} \cdot 2 \cdot \pi}{60\ \text{s}}\ =\ 104,72\ \text{rad/s}
\end{equation}


The function can not directly be implemented with the Arduino. The tachometer will generate a negative and positiv voltage corresponding to the direction of the motor. Negative voltage can not be directly inputted to the Arduino without short circuiting it, and the positive voltage would be to high. Interfacing is therefore needed between tachometer and Arduino.
This interfacing can be done trough the motor controller included in the inverted pendulum setup. The two outputs of the tachometer is inputted to the motor controller via two analogue inputs. The one acts as the positive connection and the other as the negative. How the motor controller is reacting to an input is configured trough the ESCON studio included. In the case it is set with the conversion ratio from voltage to RPM on 3,130 V/1000 RPM. The motor controller is set with a output that converts this RPM down between 1 and 4 V to the Arduino. Where 1 V is corresponding to -3000 RPM and 4 V corresponding to +3000 RPM. This gives the possibility to convert these values back to RPM in Arduino. How the motor controller converts the voltages is considered a black box.



\subsection{Implementing Motor Velocity Controller}
The following sections describes the implementation of the hardware motor controller with the Arduino. The motor driver in the setup is a Maxon Escon 50/5, which can be controlled with an Arduino trough PWM signals. 

The Maxon ESCON 50/5 is a PWM servo controller, that can be used to control DC and EC motors. The servo controller can be used in three different modes trough the Maxon ESCON studio. It can be configured in two modes for speed control with open and closed loops and feedback from sensors trough the board, and one mode for motor current control trough inputs from other modules. In setup the Escon controller is set to current control.

It is setup so that it is possible to input a PWM signal from the Arduino, which will correspond that 90\% duty cycle equals 11 A and 10\% equals -11 A. This means that 50

The main specifications of the ESCON is listed cf. table \ref{MaxonSpecifications}.

\begin{table}[htbp]
	\centering
	\begin{tabular}{llll}
	\hline
	Parameter & Value & Unit \\ \hline
	Supply voltage V$_{cc}$& 10-50 V & {[}V{]} \\
	Output voltage (max.) & 0,98$\cdot$ V$_{cc}$& {[}kg{]} \\
	Nominal output current & 5 & {[}A{]} \\
	Maximum output current (<20 s) & 15 & {[}A{]}\\
	Current control PWM frequency & 53,6 & {[}kHz{]}
	\end{tabular}
\caption{Maxon Escon 50/5 specifications.}
\label{MaxonSpecifications}
\end{table}
\todo{Ref to datasheet.}



\section{Rocket Implementation}

\subsection{Implementing Inertial Measurement Unit}

\input{chapters/"Implementation"/rocket_measurement_unit.tex}