\chapter{Implementation}
This chapter includes the implementation of controllers and components. The chapter will be seperated into two section, a section for the inverted pendulum and another section for the rocket. An Arduino will be used as the platform to implement the hardware and software on.    


\subsection{MCU}\label{sec:MCU}
TBD

\todo{Sampling speed for both system, and argument that the arduino is fine with its 16 MHz clock speed.}

\section{Inverted Pendulum Implementation}
This section describes the hardware and software implementation of the controllers designed cf. section \ref{sec:IPController}. The goal is to determine if the designed controllers will balance the stick in the real world application. The section is separated into three different parts about sensors, hardware controller and software controller. The first part is to implement the feedback for the controllers which in the case is sensors. 

\subsection{Implementing Sensors}
The following section describes the implementation of the sensors   
\todo{Consider the sampling speed of the sensors, when having the complete closed loop transfer function. - Mathias}


\subsubsection*{Potentiometer}\label{section:PotmeterImplementation}
The system consist of multiple sensors, as decribed cf. section \ref{sec:IPDesc}, where two of these are potentiometers. The potentiometers is tested cf. appendix \ref{appendix:PotMeterTest}. The appendix concluded with a first order approximation of both potentiometers. During implementation it is realized that a slight calibration were needed because of the potentiometer had shifted place in the setup. The approximation for Pot$_{arm}$ is:

\begin{equation}
\theta_a\ =\ 63,11 \cdot V_{{Pot}_{arm}} - 117,0
\end{equation}
\startexplain
	\explain{$\text{V}_{{Pot}_{arm}}$ is the output voltage of the arms potentiometer}{V}
	\explain{$\theta_a$ is the angle of the arm}{$^\circ$}
\stopexplain

The approximation for Pot$_{stick}$ is:

\begin{equation}
\theta_s\ =\ 66,66 \cdot \text{VPot}_{stick} - 163,9
\end{equation}

\startexplain
	\explain{$\text{V}_{{Pot}_{stick}}$ is the output voltage of the stick potentiometer.}{V}
	\explain{$\theta_s$ is the angle of the stick, but where zero degrees is when the stick has a zero degree deviation from the arm}{$^\circ$}
\stopexplain

An example of implementing this is done trough a pseudo-code which converts the analogue value to radians. The linear approximations of the potentiometers is used.
\begin{lstlisting}
void loop() {
  // read the input on A0 and A1:
  int PotArm = analogRead(A0);
  int PotStick = analogRead(A1);

  double VPotarm = PotArm / 204.8; //Analog2Voltage
  double ThetaA = 66.66 * VPotarm - 170.46; // Voltage2Degree
  double ThetaARad = ThetaA * (31.415926 / 1800.0); //Degree2Radians
  double VPotstick = PotStick / 204.8;
  double ThetaS = 63.64 * VPotstick - 117.77;
  double ThetaSRad = ThetaS * (31.415926 / 1800.0);
}
\end{lstlisting}    

The sampling time of the sensors is an important aspect when ensuring stability of the control system. The sensor sampling can not be to slow because then the control loops will be slow and not update fast enough. Considering that the sensor is a potentiometer which does not have any active components, then the only limit is the Arduino. Arduino specifies that calling a analogRead() takes approximately 100 $\upmu$s which corresponds to a sampling frequency of 10 kHz. This is considered fast enough for the system and is therefore not a problem. 

\subsubsection*{Tachometer}
The tachometer and its precision has been tested in appendix \ref{appendix:RPMTest}. The test concluded that the internal tachometers precision is within the limit of what could implemented. The tachometer outputs a voltage which is close to linear with the number of revolutions per minute.

The test concluded with a transfer function for the tachometer, that gives the relation between the tachometer voltage and motor velocity:
\begin{equation}
\dfrac{\dfrac{1000\ \text{RPM}}{3.130\ \text{V}} \cdot 2 \cdot \pi}{60\ \text{s}}\ \cdot\ T_{Voltage}[\text{V}]\ =\ M_{Velocity}\ \text{[rad/s]}
\end{equation}


The function can not directly be implemented with the Arduino. The tachometer will generate a negative and positive voltage corresponding to the direction of the motor. Negative voltage can not be directly input to the Arduino without short circuiting it, and the positive voltage would be to high considering that the motor can go up to 8500 RPM. Interfacing is therefore needed between tachometer and Arduino.
This interfacing is done trough the ESCON motor controller included in the inverted pendulum setup. The two outputs of the tachometer is put in to the motor controller via two analogue inputs. The one acts as the positive connection and the other as the negative. How the motor controller is reacting to an input is configured trough the ESCON studio included. In the case it is set with the conversion ratio from voltage to RPM on 3,130 V/1000 RPM, which was determined by external calibration from another tachometer and implemented in the software.  The motor controller is set with a output that converts this RPM down between 1 and 4 V to the Arduino. Where 1 V is corresponding to -3000 RPM and 4 V corresponding to +3000 RPM. This gives the possibility to convert these values back to RPM in Arduino. How the motor controller converts the voltages is considered a black box. The wiring for the tachometer can be seen cf. figure \ref{fig:EsconWiring}. 


\subsection{Implementing ESCON Motor Controller}
The following sections describes the implementation of the hardware motor controller with the Arduino. The motor controller in the setup is a Maxon Escon 50/5.

The Maxon ESCON 50/5 is a PWM servo controller, that can be used to control DC and EC motors. The application is to amplify signals and control systems trough different control operations. It can also be used with a PWM input signal that can be outputted as an amplified and higher frequency PWM signal to a motor. The servo controller can be used in three different modes which can be configured trough the included Maxon ESCON studio. It can be configured in two modes for speed control with open and closed loops with feedback from sensors trough the board, and one mode for motor current control trough inputs from other modules such as an Arduino. In the setup the Escon controller is set to current control.


It is setup trough the ESCON studio with current control, and with a external controlled PWM signal. It then gives the possibility to input a PWM signal from the Arduino, which will be amplified so that 90\% duty cycle equals 11 A and 10\% equals -11 A. This means that 50\% will give 0 A. The configuration file is included in the attachment files under "/Attachment/Implementation/Motor Controller/Motor Controller Configuration File". It can be imported into the ESCON studio and loaded onto any 50/5 controller.

The main specifications of the ESCON is listed cf. table \ref{MaxonSpecifications}.

\begin{table}[htbp]
	\centering
	\begin{tabular}{llll}
	\hline
	Parameter & Value & Unit \\ \hline
	Supply voltage V$_{cc}$& 10-50 V & {[}V{]} \\
	Output voltage (max.) & 0,98 $\cdot$ V$_{cc}$& {[}kg{]} \\
	Nominal output current & 5 & {[}A{]} \\
	Maximum output current (<20 s) & 15 & {[}A{]}\\
	Current control PWM frequency & 53,6 & {[}kHz{]}
	\end{tabular}
\caption{Maxon Escon 50/5 specifications\citep{datasheet:maxon}.}
\label{MaxonSpecifications}
\end{table}

They wiring for the setup can be seen cf. figure \ref{fig:EsconWiring}.  

\begin{figure}[htbp]
\centering
\includegraphics[width=0.85\linewidth]{figures/MotorControllerSetup}
\caption{Wiring for the control setup.}
\label{fig:EsconWiring}
\end{figure}

The control PWM signal from the Arduino is set with a frequency of 5 kHz because that it is the maximum input frequency the motor controller will accept. It is set to 5 kHz so that the PWM avoids interference with the sampling frequency for the system. The input PWM signal is then amplified and made faster. The output PWM frequency of the motor controller is 53,6 kHz with a duty cycle from 10 - 90\% which can not be changed in the ESCON studio. It is considered that the switching frequency of the ESCON is close to optimal when considering that the PWM frequencies is within the limit of what its datasheet specifies.   The main concern of a switching frequency of 53,6 kHz on the motor would be heat dissipation. Therefore the minimum PWM frequency for the motor is calculated to see if the motor controllers PWM frequency fits the motor.

\subsubsection{Calculating Minimum PWM Frequency}
The only PWM frequency considered is the minimum switching frequency for the motor. This is done by considering the motor resistance and inductance versus the maximum amount of current ripple wanted on the motor. The values for the resistance and the inductance of the motor are calculated in appendix \ref{tab_appendix:KeSetUp}. The formula is seen cf. \ref{eq:PWMSwitch} [Palle Andersen, 2016].

\begin{equation}
f_{switch} \geq \frac{-1}{2\cdot ln(1-\frac{p}{100})}\cdot\frac{R_{m}}{L_{m}}
\label{eq:PWMSwitch}
\end{equation}
Where:\\
\begin{tabular}{m{8em} m{25em} m{8em}}
$p$& The maximum \% current ripple in the motor. & [1]\\
$\frac{R_{m}}{L_{m}}$& The inverse electrical time constant of the motor.& [Hz]\\
\\
\end{tabular}

Replacing with the numerical values of the resistance and the inductance and choosing a max ripple percentage of 5\%, the minimum switching frequency determined to be:
\begin{equation}
    f_{switch} \geq \frac{-1}{2 \cdot ln(1-\frac{5}{100})}\cdot\frac{0,82\ \Omega}{156\cdot10^-6 \ \cdot \text{H}} \approx \ 51,2 \text{kHz}
\end{equation}

The maximum ripple in the motor is determined by making the ripple the unknown factor P$_{ripple}$ and setting the PWM frequency to the implemented 53,6 kHz.  

\begin{equation}
    53,6 \text{kHz} = \frac{-1}{2 \cdot ln(1-\frac{P_{ripple}}{100})}\cdot\frac{0,82\ \Omega}{156\cdot10^-6 \ \cdot \text{H}}\ =\ P_{ripple}\ = 4,785\%  
\end{equation}
This gives that the maximum current ripple is 4,785\% if considering a PWM frequency on 53,6 kHz. A general rule is that the ripple should be less than 10\% of the current, so considering that is less than 5\% is good considering that the system is implemented with current control.   
 
\subsection{Implementing Controllers}
The implementing on the hardware has been described in the chapter, and therefore the implementation can proceed to the implementing the controllers on an Arduino. 

\subsubsection{Implementing Controller for the Arm Loop}
TBD

\subsubsection{Implementing Controller for the Motor Loop}
TBD
\subsubsection{Implementing Controller for the Stick Loop}
TBD

\section{Rocket Implementation}

\subsection{Implementing Inertial Measurement Unit}

\input{chapters/"Implementation"/rocket_measurement_unit.tex}